
class World {
  field Array _world;

  constructor World new() {
    var int i;

    let _world = Array.new(512);
    let i = 0;
    while (i < 512) {
      let _world[i] = 0;
      let i = i + 1;
    }

    return this;
  }

  function int find_index_from_cell(int col, int row) {
    var int index;

    if ((col < 0) | (col > 31)) {
      return -1;
    }
    if ((row < 0) | (row > 15)) {
      return -1;
    }

    let index = 32 * row + col;

    return index;
  }

  function int math_mod(int c, int m) {
    var int result, d;

    if (c < m) {
      let result = c;
    } else {
      let d = c / m;
      let result = c - (d * m);
    }

    return result;
  }

  method boolean is_filled(int i) {
    return _world[i];
  }

  method int _count_as_life_if_filled(int c, int r, int lives) {
    var int index;
    let index = World.find_index_from_cell(c, r);

    if (index = -1) {
      return lives;
    }

    if (is_filled(index)) {
      let lives = lives + 1;
    }
    return lives;
  }

  method int count_neighbors_lives_from_cell(int col, int row) {
    var int x, y, c, r;
    var int lives;

    let lives = 0;
    let x = col;
    let y = row;

    let c = x-1;
    let r = y-1;
    let lives = _count_as_life_if_filled(c, r, lives);

    let c = x;
    let r = y-1;
    let lives = _count_as_life_if_filled(c, r, lives);

    let c = x+1;
    let r = y-1;
    let lives = _count_as_life_if_filled(c, r, lives);

    let c = x-1;
    let r = y;
    let lives = _count_as_life_if_filled(c, r, lives);

    let c = x+1;
    let r = y;
    let lives = _count_as_life_if_filled(c, r, lives);

    let c = x-1;
    let r = y+1;
    let lives = _count_as_life_if_filled(c, r, lives);

    let c = x;
    let r = y+1;
    let lives = _count_as_life_if_filled(c, r, lives);

    let c = x+1;
    let r = y+1;
    let lives = _count_as_life_if_filled(c, r, lives);

    return lives;
  }
  
  method void draw_world() {
    var int i;
    var int x, y;

    let i = 0;
    while (i < 512) {
      if (_world[i] = 1) {
        // Find Cell position x, y from index.
        // x = index % 32, where 32 is the size of row.
        // y is index / 32.
        let x = World.math_mod(i, 32);
        let y = Math.divide(i, 32);

        do Display.DrawCell(x, y);
      }
      let i = i + 1;
    }

    return;
  }

  method int calc_new_cell_state(int index) {
    var int lives;
    var int x, y;

    let x = World.math_mod(index, 32);
    let y = Math.divide(index, 32); 
    let lives = count_neighbors_lives_from_cell(x, y);

    if (is_filled(index)) {
      // do Output.printInt(index);
      // do Output.printString(", lives:");
      // do Output.printInt(lives);
      // do Output.printString(".....");
      if ((lives = 3) | (lives = 2)) {
        // do Output.printString("FILLED:");
        // do Output.printInt(index);
        // do Output.printString("...");
        return 1;
      }
    } else {
      if (lives = 3) {
        // do Output.printString("EMPTY:");
        // do Output.printInt(index);
        // do Output.printString("...");
        return 1;
      }
    }

    return 0;
  }

  method void set_pattern(int index) {
    let _world[index] = 1;
    return;
  }

  method void draw_beacon(int pos) {
    let _world[pos] = 1;
    let _world[pos + 1] = 1;
    let _world[pos + 32] = 1;
    let _world[pos + 33] = 1;

    let _world[pos + 66] = 1;
    let _world[pos + 67] = 1;
    let _world[pos + 98] = 1;
    let _world[pos + 99] = 1;

    return;
  }

  method void draw_glider(int pos) {
    /*   x
          x
        xxx
    */
    let _world[pos] = 1;
    let _world[pos + 33] = 1;
    let _world[pos + 63] = 1;
    let _world[pos + 64] = 1;
    let _world[pos + 65] = 1;
    return;
  }

  method void draw_penta(int pos) {
    let _world[pos] = 1;
    let _world[pos + 31] = 1;
    let _world[pos + 33] = 1;

    let _world[pos + 62] = 1;
    let _world[pos + 66] = 1;
    let _world[pos + 94] = 1;
    let _world[pos + 98] = 1;

    let _world[pos + 126] = 1;
    let _world[pos + 130] = 1;
    let _world[pos + 158] = 1;
    let _world[pos + 162] = 1;
    let _world[pos + 190] = 1;
    let _world[pos + 194] = 1;
    let _world[pos + 222] = 1;
    let _world[pos + 226] = 1;
    let _world[pos + 255] = 1;
    let _world[pos + 257] = 1;
    let _world[pos + 288] = 1;

    return;
  }

  method void draw_toad(int pos) {
    let _world[pos] = 1;
    let _world[pos + 1] = 1;
    let _world[pos + 2] = 1;
    let _world[pos + 31] = 1;
    let _world[pos + 32] = 1;
    let _world[pos + 33] = 1;

    return;
  } 

  method void run() {
    var int count;
    var int index, i;
    var Array new_world;

    let count = 0;
    while (count < 1000) {
      do draw_world();

      let new_world = Array.new(512);
      let index = 0;
      while (index < 512) {
        let new_world[index] = calc_new_cell_state(index);
        let index = index + 1;
      }

      // deep copy
      let i = 0;
      while (i < 512) {
        let _world[i] = new_world[i];
        let i = i + 1;
      }
      do new_world.dispose();

      do Sys.wait(100);
      do Display.EmptyBoard();

      let count = count + 1;
    }

    return;
  }
}
